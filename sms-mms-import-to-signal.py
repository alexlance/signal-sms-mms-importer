import xml.etree.ElementTree as ET
import sys  # noqa
import os
import sqlite3
import base64
import time
import logging

logging.basicConfig(filename='signalsmsmmsimport.log', filemode='a', format='%(asctime)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S', level=logging.DEBUG)

#todo:
# finish mms/rcs message import correction
# make them dictionaries instead of lists where possible (readability/performance)
# make a reliable equivalent to oracle merge? delete/add? update? optional arguments/yesno prompts to ask about the 'delete equivalent things' prcoess?
# create recipient when not exist?
# have mms/sms appear as such in signal, not as signal messages
# hangle group things

def get_contacts(cursor):
    cursor.execute("select _id, phone, system_display_name from recipient")
    contacts = cursor.fetchall()
    contacts_by_number = {}
    for c in contacts:
        if c[1]:
            contacts_by_number[c[1]] = c[0]
            contacts_by_number[c[1].replace("+61", "0")] = c[0]
            contacts_by_number[c[1].replace("+61", "0").replace("-", "")] = c[0]
    return contacts_by_number


def get_parts(r):
    rtn = []
    # print("GETTING PARTS:")
    for parts in r.findall("parts"):
        for part in parts.findall("part"):
            rtn.append(part)
    return rtn


def get_addrs(r):
    rtn = []
    # print("GETTING ADDRS:")
    for addrs in r.findall("addrs"):
        for addr in addrs.findall("addr"):
            rtn.append(addr)
    return rtn

input = sys.argv[1]
output = sys.argv[2]

# parse the XML file generated by SMS Backup and Restore (by SyncTech)
tree = ET.parse(input)
root = tree.getroot()

# parse the sqlite database generated by github.com/bepaald/signalbackup-tools
conn = sqlite3.connect(os.path.join(output, "database.sqlite"))
cursor = conn.cursor()

smses = []
mmses = []
contacts_by_number = get_contacts(cursor)

for r in root:
    date_sent = r.attrib.get("date_sent","")
    if date_sent in [0, "0", ""]:
        date_sent = r.attrib.get("date","")
    address = False
    add = r.attrib["address"].replace("-", "").replace("+61","0")
    # some sms conversations seem to have multiple recipients separated by a tilda
    # I don't really know how to craft a signal group chat (although I do see a group table)
    # So we're just going to grab one of the contacts in the group and make them the
    # recipient ... sure wish the Signal database had some documentation ...
    if '~' in add:
        for a in sorted(add.split("~")):
            try:
                address = contacts_by_number[a]
                logging.info(f"Coerced group of {add} to a single contact: {a}")
            except KeyError:
                pass
    if not address:
        try:
            address = contacts_by_number[add]
        except KeyError:
            pass
    if not address:
        logging.warning(f"Skipping {r.tag} because couldn't link address to a contact: {r.attrib['address']}")
        #logging.warning(r.items())
        # sys.exit(0)
        # cursor.execute("insert into recipient (phone, system_display_name) values (?, ?)", (r.attrib["address"],.....))
        continue
    if r.tag == "sms":
        # magic Signal numbers
        typ = 10485783 if str(r.attrib["type"]) == "2" else 10485780
        row = (
            address,
            r.attrib["date"],
            date_sent,
            1,  # "read"
            -1,  # "status"
            int(typ),
            r.attrib["body"],
        )
        smses.append(row)
    elif r.tag == "mms":
        # magic Signal numbers, 10485783 for messages we've sent, 10485780 for messages we've received
        typ = 10485783 if str(r.attrib["msg_box"]) == "2" else 10485780
        addrs = get_addrs(r)
        parts = get_parts(r)
        text = ""
        for text_part in parts:
            if text_part.get("seq") == '0':
                text = text_part.get("text","")
                if text == "null":
                    text =""
        row = (
            address,
            r.attrib["date"],
            date_sent,
            1,  # "read"
            -1,  # "status",
            typ,
            r.attrib.get("body", text),
            parts,
            addrs,
        )
        mmses.append(row)

logging.info(f"Found {str(len(smses))} sms")
logging.info(f"Found {str(len(mmses))} mms")

time.sleep(3)


def get_or_make_thread(cursor, r, doUpdate=False, doDelete=False):
    thread_id = False
    cursor.execute(f"select _id from thread where thread_recipient_id = '{r[0]}'")
    rows = cursor.fetchall()
    if len(rows):
        thread_id = rows[0][0]
    if thread_id:
        if doUpdate:
            # print("Updating thread:", thread_id, r)
            cursor.execute(
                "update thread set date = ?, message_count = message_count + 1, snippet = ? where _id = ?",
                (r[1], str(r[6])[0:100], thread_id),)
        if doDelete:
            cursor.execute(f"update thread set date = '{r[1]}', message_count = message_count - 1, snippet = '{str(r[6])[0:100]}' where _id = {thread_id}")
    else:
        # print("Creating new thread:", r)
        cursor.execute(
            "insert into thread (date, thread_recipient_id, message_count, snippet) VALUES (?, ?, ?, ?)",
            (r[1], r[0], 1, str(r[6])[0:100]),
        )
        cursor.execute("select max(_id) as thread_id from thread")
        rows = cursor.fetchall()
        if len(rows):
            thread_id = rows[0][0]
    return thread_id

logging.info("deleting existing MMS to replace")

for r in mmses:
    thread_id = get_or_make_thread(cursor, r)
    cursor.execute(f"select _id as mms_id from mms where address = {r[0]} and date = {r[1]}")
    rows = cursor.fetchall()
    for mms_id in rows:
        cursor.execute(f"delete from part where mid = '{mms_id}'")
        conn.commit()
        print('deleted a part')
    cursor.execute(f"delete from mms where address = '{r[0]}' and date = '{r[1]}';")
    conn.commit()


for r in mmses:
    thread_id = get_or_make_thread(cursor, r)
    part_count = len(r[7])

    m_type = 128  # 128 == we sent
    if r[5] == 10485780:
        m_type = 132  # 132 == we received
    logging.info(f"Writing MMS: {r}")
    q = "INSERT INTO mms ( \
           thread_id, date, date_received, date_server, msg_box, read, body, part_count, address, \
           delivery_receipt_count, read_receipt_count, viewed_receipt_count, m_type) \
         VALUES \
           (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
    cursor.execute(
        q,
        (thread_id, r[1], r[2], r[1], r[5], 1, r[6], part_count, r[0], 1, 1, 1, m_type),
    )
    conn.commit()
    cursor.execute("select max(_id) as mms_id from mms")
    rows = cursor.fetchall()
    mms_id = rows[0][0]
    seq = 0
    logging.info(f"PARTS found {len(r[7])} parts")
    for part in r[7]:
        # skip smil - not sure if Signal undestand SMIL formatting
        if int(part.attrib.get("seq", 0)) != -1 and part.attrib.get("data"):
            seq += 1
            logging.info(f"  Working on mms {mms_id} part number {seq}")
            data = base64.b64decode(part.attrib["data"])
            data_size = len(data)
            file_name = part.attrib.get("name", part.attrib.get("cl", ""))
            # something needs to be tweaked around here, file names are still coming across as null
            if file_name == "" or file_name == "null":
                file_name = part.attrib.get("cid", "")
            file_name = (
                file_name.replace("&lt;", "")
                .replace("&gt;", "")
                .replace("<", "")
                .replace(">", "")
            )
            unique_id = int(time.time() * 1000)
            logging.info(f"    -> file: {file_name} is {data_size} bytes")
            props = '{"skipTransform":true,"videoTrim":false,"videoTrimStartTimeUs":0,"videoTrimEndTimeUs":0,"sentMediaQuality":0,"videoEdited":false}'
            q = "INSERT INTO part (mid, seq, ct, name, chset, data_size, file_name, unique_id, caption, transform_properties) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
            cursor.execute(
                q,
                (
                    mms_id,
                    seq,
                    part.attrib.get("ct"),
                    file_name,
                    file_name,
                    # part.attrib.get("chset"),
                    data_size,
                    file_name,
                    unique_id,
                    part.attrib.get("text", ""),
                    props
                ),
            )
            conn.commit()
            cursor.execute("select max(_id) as part_id from part")
            rows = cursor.fetchall()
            part_id = rows[0][0]
            # dump the attachments in the folder the way that signalbackup-tools likes to have them
            fname = f"{output}/Attachment_{part_id}_{unique_id}.bin"
            fname2 = f"{output}/Attachment_{part_id}_{unique_id}.sbf"
            with open(fname, "wb") as f:
                logging.info(f"      * writing: {fname}")
                f.write(data)
            fdesc = f"ROWID:uint64:{part_id}\n\
ATTACHMENTID:uint64:{unique_id}\n\
LENGTH:uint32:{data_size}"
            with open(fname2, "w") as f:
                logging.info(f"      * writing: {fname2}")
                f.write(fdesc)


# process normal smses too (this tends to be slower cause there's generally more of them)

for r in smses:
    thread_id = get_or_make_thread(cursor, r, True)
    r = list(r)
    r.insert(0, thread_id)
    r = tuple(r)
    cursor.execute(f"delete from sms where address = '{r[1]}' and date = '{r[2]}'")
    conn.commit()
    logging.info(f"Writing SMS: {r}")
    cursor.execute(
        "INSERT INTO sms (thread_id, address, date, date_sent, read, status, type, body, delivery_receipt_count, read_receipt_count) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, 1)",
        r,
    )
    conn.commit()


conn.commit()
cursor.close()
