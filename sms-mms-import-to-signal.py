import xml.etree.ElementTree as ET
import sys  # noqa
import os
import sqlite3
import base64
import time


def get_contacts(cursor):
    cursor.execute("select _id, phone, system_display_name from recipient")
    contacts = cursor.fetchall()
    contacts_by_number = {}
    for c in contacts:
        if c[1]:
            contacts_by_number[c[1]] = c[0]
            contacts_by_number[c[1].replace("+61", "0")] = c[0]
            contacts_by_number[c[1].replace("+61", "0").replace("-", "")] = c[0]
    return contacts_by_number


def get_parts(r):
    rtn = []
    # print("GETTING PARTS:")
    for parts in r.findall("parts"):
        for part in parts.findall("part"):
            rtn.append(part)
    return rtn


def get_addrs(r):
    rtn = []
    # print("GETTING ADDRS:")
    for addrs in r.findall("addrs"):
        for addr in addrs.findall("addr"):
            rtn.append(addr)
    return rtn


# parse the XML file generated by SMS Backup and Restore (by SyncTech)
tree = ET.parse(sys.argv[1])
root = tree.getroot()

# parse the sqlite database generated by github.com/bepaald/signalbackup-tools
conn = sqlite3.connect(os.path.join(sys.argv[2], "database.sqlite"))
cursor = conn.cursor()

smses = []
mmses = []
contacts_by_number = get_contacts(cursor)

for r in root:

    date_sent = r.attrib["date_sent"]
    if date_sent == 0 or date_sent == "0" or date_sent == "" or not date_sent:
        date_sent = r.attrib["date"]

    address = False
    add = r.attrib["address"].replace("-", "")

    # some sms conversations seem to have multiple recipients separated by a tilda
    # I don't really know how to craft a signal group chat (although I do see a group table)
    # So we're just going to grab one of the contacts in the group and make them the
    # recipient ... sure wish the Signal database had some documentation ...
    if '~' in add:
        for a in sorted(add.split("~")):
            try:
                address = contacts_by_number[a]
                print("Coerced group of ", add, " to a single contact: ", a)
            except KeyError:
                pass

    if not address:
        try:
            address = contacts_by_number[add]
        except KeyError:
            pass

    if not address:
        print("\nSkipping ", r.tag, " because couldn't link address to a contact: ", r.attrib["address"])
        print(r.items())
        # sys.exit(0)
        # cursor.execute("insert into recipient (phone, system_display_name) values (?, ?)", (r.attrib["address"],.....))
        continue

    if r.tag == "sms":

        # magic Signal numbers
        typ = 10485783 if str(r.attrib["type"]) == "2" else 10485780

        row = (
            address,
            r.attrib["date"],
            date_sent,
            1,  # "read"
            -1,  # "status"
            int(typ),
            r.attrib["body"],
        )
        smses.append(row)
    elif r.tag == "mms":

        # magic Signal numbers, 10485783 for messages we've sent, 10485780 for messages we've received
        typ = 10485783 if str(r.attrib["msg_box"]) == "2" else 10485780

        row = (
            address,
            r.attrib["date"],
            date_sent,
            1,  # "read"
            -1,  # "status",
            typ,
            r.attrib.get("body", ""),
            get_parts(r),
            get_addrs(r),
        )
        mmses.append(row)

print("Found ", len(smses), "sms")
print("Found ", len(mmses), "mms")
time.sleep(3)


def get_or_make_thread(cursor, r, doUpdate=False):
    thread_id = False
    cursor.execute("select _id from thread where thread_recipient_id = ?", (r[0],))
    rows = cursor.fetchall()
    if len(rows):
        thread_id = rows[0][0]

    if thread_id:
        if doUpdate:
            # print("Updating thread:", thread_id, r)
            cursor.execute(
                "update thread set date = ?, message_count = message_count + 1, snippet = ? where _id = ?",
                (r[1], str(r[6])[0:100], thread_id),
            )
    else:
        # print("Creating new thread:", r)
        cursor.execute(
            "insert into thread (date, thread_recipient_id, message_count, snippet) VALUES (?, ?, ?, ?)",
            (r[1], r[0], 1, str(r[6])[0:100]),
        )
        cursor.execute("select max(_id) as thread_id from thread")
        rows = cursor.fetchall()
        if len(rows):
            thread_id = rows[0][0]
    return thread_id


dest = sys.argv[2]
for r in mmses:
    thread_id = get_or_make_thread(cursor, r)
    part_count = len(r[7])

    m_type = 128  # 128 == we sent
    if r[5] == 10485780:
        m_type = 132  # 132 == we received

    print("Writing MMS: ", r)
    q = "INSERT INTO mms ( \
           thread_id, date, date_received, date_server, msg_box, read, body, part_count, address, \
           delivery_receipt_count, read_receipt_count, viewed_receipt_count, m_type) \
         VALUES \
           (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    cursor.execute(
        q,
        (thread_id, r[1], r[2], r[1], r[5], 1, r[6], part_count, r[0], 1, 1, 1, m_type),
    )
    conn.commit()

    cursor.execute("select max(_id) as mms_id from mms")
    rows = cursor.fetchall()
    mms_id = rows[0][0]

    seq = 0
    print(f"PARTS found {len(r[7])} parts")
    for part in r[7]:
        # skip smil - not sure if Signal undestand SMIL formatting
        if int(part.attrib.get("seq", 0)) != -1 and part.attrib.get("data"):
            seq += 1
            print(f"  Working on mms {mms_id} part number {seq}")
            data = base64.b64decode(part.attrib["data"])
            data_size = len(data)
            file_name = part.attrib.get("name", part.attrib.get("cl", ""))

            # something needs to be tweaked around here, file names are still coming across as null
            if file_name == "" or file_name == "null":
                file_name = part.attrib.get("cid", "")
            file_name = (
                file_name.replace("&lt;", "")
                .replace("&gt;", "")
                .replace("<", "")
                .replace(">", "")
            )

            unique_id = int(time.time() * 1000)
            print(f"    -> file: {file_name} is {data_size} bytes")

            props = '{"skipTransform":true,"videoTrim":false,"videoTrimStartTimeUs":0,"videoTrimEndTimeUs":0,"sentMediaQuality":0,"videoEdited":false}'

            q = "INSERT INTO part (mid, seq, ct, name, chset, data_size, file_name, unique_id, caption, transform_properties) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
            cursor.execute(
                q,
                (
                    mms_id,
                    seq,
                    part.attrib.get("ct"),
                    file_name,
                    file_name,
                    # part.attrib.get("chset"),
                    data_size,
                    file_name,
                    unique_id,
                    part.attrib.get("text", ""),
                    props
                ),
            )
            conn.commit()

            cursor.execute("select max(_id) as part_id from part")
            rows = cursor.fetchall()
            part_id = rows[0][0]

            # dump the attachments in the folder the way that signalbackup-tools likes to have them
            fname = f"{dest}/Attachment_{part_id}_{unique_id}.bin"
            fname2 = f"{dest}/Attachment_{part_id}_{unique_id}.sbf"
            with open(fname, "wb") as f:
                print(f"      * writing: {fname}")
                f.write(data)

            fdesc = f"ROWID:uint64:{part_id}\n\
ATTACHMENTID:uint64:{unique_id}\n\
LENGTH:uint32:{data_size}"
            with open(fname2, "w") as f:
                print(f"      * writing: {fname2}")
                f.write(fdesc)


# process normal smses too (this tends to be slower cause there's generally more of them)
for r in smses:
    thread_id = get_or_make_thread(cursor, r, True)

    r = list(r)
    r.insert(0, thread_id)
    r = tuple(r)
    print("Writing SMS: ", r)
    cursor.execute(
        "INSERT INTO sms (thread_id, address, date, date_sent, read, status, type, body, delivery_receipt_count, read_receipt_count) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, 1)",
        r,
    )
    conn.commit()


conn.commit()
cursor.close()
